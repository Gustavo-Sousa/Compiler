// https://cs.lmu.edu/~ray/notes/javacc/

PARSER_BEGIN(Parser)

public class Parser {
    public static void main(String[] args) {
        try {
            new Parser(new java.io.FileInputStream(args[0])).S(); // Source code
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Parser)

TOKEN : {   
    // Bold keywords from book
        <PUBLIC : "public"> // Lowercase pattern
    |   <STATIC : "static">
    |   <VOID : "void">
    |   <MAIN : "main">

    |   <CLASS : "class">
    |   <EXTENDS : "extends">

    |   <PRINT : "System.out.println">

    |   <THIS : "this">
    |   <NEW : "new">
    |   <STRING : "String"> 
    |   <INT: "int">
    |   <RETURN : "return">

    |   <BOOLEAN: "boolean">
    |   <TRUE : "true">
    |   <FALSE : "false">

    |   <IF : "if">
    |   <ELSE : "else">
    |   <WHILE : "while">

    |   <LENGTH : "length">

    // Some local tokens necessary bellow
    |   <#LETTER : ["A" - "Z"]["a"-"b"] > 
    |   <#DIGIT : ["0"-"9"] >
    |   <#REAL : (
                    (<DIGIT>)+ "." (<DIGIT>)*  // Real numbers can be like this way
                  ) |
                 (
                    (<DIGIT>)* "." (<DIGIT>)+  // Or this
                  ) >
    |   <#INTERGER : (<DIGIT>)+ > //  Maybe this is unnecessary
    
    // The lexical issues
    |   <ID: ( <LETTER>(<LETTER> | <DIGIT> | "-")* ) >  // Expression migh be in parenthesis
    |   <INTERGER_LITERAL : <ID> | <INTERGER> | <REAL> >  // Maybe necessary change id token
    |   <OP : "&&" | "<" | "+" | "-" | "*"> // Tenho dúvida em usar isso

    // Necessary symbols
    |   <AND : "&&">
    |   <OR : "||">
    |   <EQUAL : "=">

    |   <LESS_THEN : "<">
    |   <BIGGER_THEN : ">">
    |   <PLUS : "+">
    |   <MINUS : "-">
    |   <TIMES : "*">
    |   <BAR : "/">

    |   <LPAREN : "(">
    |   <RPAREN : ")">
    |   <LBRACE : "{">
    |   <RBRACE : "}">
    |   <RBRACE_INTER : ")?">
    |   <LCOLCH : "[">
    |   <RCOLCH : "]">

    |   <BANG : "!">
    |   <DOT : ".">
    |   <COMMA : ",">
    |   <SEMI_COMMA : ";">


}

SKIP : {
     " " | "\t" | "\n" | "\r"
}


// Por enquanto retornam apenas void

void Program():	{}{
	MainClass() 
	(ClassDecl())*
}

void MainClass():	{}{
	<CLASS>
	Id()
	<LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
	<LPAREN> <STRING> <LCOLCH> <RCOLCH> Id() <RPAREN>
	<LBRACE> Statement() <RBRACE>
	<RBRACE>
}

void ClassDecl():	{  // Correction

}{ 
	<CLASS> Id() ClassDecl_Aux()

}

void ClassDecl_Aux():	{}{
		(<LBRACE> (VarDecl())* (MethodDecl())* <RBRACE>)
	|	(
		<EXTENDS> Id() 
		<LBRACE> Id() (VarDecl())* (MethodDecl())* <RBRACE>
		)
	|	{}  // Empty definition
}

void VarDecl():	{}{
	Type() Id()
}

void MethodDecl():	{}{
	<PUBLIC> Type() Id()
	<LPAREN> FormalList() <RPAREN>
	<LBRACE> ( LOOKAHEAD(2) VarDecl())* (Statement())* <RETURN> Exp() <SEMI_COMMA> <RBRACE>
}

void FormalList():	{}{
	Type() Id() (FormalRest())* | {}
}

void FormalRest():	{}{
	<COMMA> Type() Id()
}

void Type():	{}{
		LOOKAHEAD(2) Id() <LCOLCH> <RCOLCH> // Warning correction:I think that its the line of the earlier expansion
	|	<BOOLEAN> 
	|	<INT> 
	|	Id()
}

void Statement():	{  // Dúvida
	
}{
		<LBRACE> (Statement())* <RBRACE>
	|	<IF> Statement() <ELSE> Statement()
	|	<WHILE> <LPAREN> Exp() <RPAREN> Statement()
	|	<PRINT> <LPAREN> Exp() <RPAREN> <SEMI_COMMA>
	|	LOOKAHEAD(2) Id() <EQUAL> Exp() <SEMI_COMMA>
	|	Id() <LCOLCH> Exp() <RCOLCH> <EQUAL> Exp() <SEMI_COMMA>
}

void Exp():	{  // Correction

}{
		<TRUE> Exp_Aux()
	|	<FALSE> Exp_Aux()
	|	<INTERGER_LITERAL> Exp_Aux()
	|	Id() Exp_Aux()
	|	<THIS> Exp_Aux()
	|	LOOKAHEAD(2) <NEW> <INT> <LCOLCH> Exp() <RCOLCH> Exp_Aux()
	|	<NEW> Id() <LPAREN> <RPAREN> Exp_Aux()
	|	<LPAREN> Exp() <RPAREN> Exp_Aux()
	|	<BANG> Exp() Exp_Aux()
}

void Exp_Aux():	{}{
		<OP> Exp() Exp_Aux()
	|	<LCOLCH> Exp() <RCOLCH> Exp_Aux()
	|	LOOKAHEAD(2) <DOT> <LENGTH> Exp_Aux()
	|	<DOT> Id() <LPAREN> ExpList() <RPAREN> Exp_Aux()
	|	{}
}

void ExpList():	{}{
		Exp() (ExpRest())*
	|	{}
}

void ExpRest():	{}{
	<COMMA> Exp()
}

void Id():	{}{  // Declared and struture
	<ID>
}