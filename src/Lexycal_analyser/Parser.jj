// https://cs.lmu.edu/~ray/notes/javacc/

PARSER_BEGIN(Parser)

public class Parser {
    public static void main(String[] args) {
        try {
            new Parser(new java.io.FileInputStream(args[0])).S(); // Source code
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

PARSER_END(Parser)

TOKENS: {   
    // Bold keywords from book
        <PUBLIC : "public"> // Lowercase pattern
    |   <STATIC : "static">
    |   <VOID : "void">
    |   <MAIN : "main">

    |   <CLASS : "class">
    |   <EXTENDS : "extends">

    |   <PRINT : "System.out.println">

    |   <THIS : "this">
    |   <NEW : "new">
    |   <STRING : "String"> 
    |   <INT: "int">
    |   <RETURN : "return">

    |   <BOOLEAN: "boolean">
    |   <TRUE : "true">
    |   <FALSE : "false">

    |   <IF : "if">
    |   <ELSE : "else">
    |   <WHILE : "while">

    |   <LENGTH : "length">

    // Some local tokens necessary bellow
    |   <#LETTER : ["A" - "Z"]["a"-"b"] > 
    |   <#DIGIT : ["0"-"9"] >
    |   <#REAL : (
                    (<DIGIT>)+ "." (<DIGIT>)*  // Real numbers can be like this way
                  ) |
                 (
                    (<DIGIT>)* "." (<DIGIT>)+  // Or this
                  ) >
    |   <#INTERGER : (<DIGTT>)+  //  Maybe this is unnecessary
    
    // The lexical issues
    |   <ID : <LETTER>(<LETTER> | <DIGIT> | "-")*> 
    |   <INTERGER_LITERAL : <ID> | <INTERGER> | <REAL> >
    |   <OP : "&&" | "<" | "+" | "-" | "*"> // Tenho dúvida em usar isso

    // Necessary symbols
    |   <AND : "&&">
    |   <OR : "||">
    |   <EQUAL : "=">

    |   <LESS_THEN : "<">
    |   <BIGGER_THEN : ">">
    |   <PLUS : "+">
    |   <MINUS : "-">
    |   <TIMES : "*">
    |   <BAR : "/">

    |   <LPAREN : "(">
    |   <RPAREN : ")">
    |   <LBRACE : "{">
    |   <RBRACE : "}">
    |   <RBRACE_INTER : ")?">
    |   <LCOLCH : "[">
    |   <RCOLCH : "]">

    |   <BANG : "!">
    |   <DOT : ".">
    |   <COMMA : ",">
    |   <SEMI_COMMA : ";">


}

SKIP: {
     " " | "\t" | "\n" | "\r"
}


// Por enquanto retornam apenas void

void Program(){}{
	MainClass()
	(ClassDecl)*
}

void MainClass(){}{
	<CLASS>
	<ID>
	<LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN>
	<LPAREN> <STRING> <LCOLCH> <RCOLCH> <ID> <RPAREN>
	<LBRACE> Statement() <RBRACE>
	<RBRACE>
}

void ClassDecl(){  // Correction

}{ 
	<CLASS> <ID> ClassDecl_Aux()

}

void ClassDEcl_Aux(){}{
	(<LBRACE> (VarDecl)* (MethodDecl)* <RBRACE>) |
	(
	<EXTENDS> <ID> 
	<LBRACE> <ID> (VarDecl)* (MethodDecl)* <RBRACE>
	)
}

void VarDecl(){}{
	Type() <ID>
}

void MethodDecl(){}{
	<PUBLIC> Type() <ID>
	<LPAREN> FormalList() <RPAREN>
	<LBRACE> (VarDecl)* (Statement())* <RETURN> Exp() <SEMI_COMMA> <RBRACE>
}

void FormalList(){}{
	Type() <ID> (FormalRest())* | " "
}

void FormalRest(){}{
	<COMMA> Type() <ID>
}

void Type(){}{
		<ID> <LCOLCH> <RCOLCH>
	|	<BOOLEAN> 
	|	<INT> 
	|	<ID>
}

void Statement(){  // Dúvida
	
}{
		<LBRACE> (Statement())* <RBRACE>
	|	<IF> Statement() <ELSE> Statement()
	|	<WHILE> <LPAREN> Exp() <RPAREN> Statement()
	|	<PRINT> <LPAREN> Exp() <RPAREN> <SEMI_COMMA>
	|	<ID> <EQUAL> Exp() <SEMI_COMMA>
	|	<ID> <LCOLCH> <Exp() <RCOLCH> <EQUAL> Exp() <SEMI_COMMA>
}

void Exp(){  // Correction

}{
		<TRUE> Exp_Aux()
	|	<FALSE> Exp_Aux()
	|	<INTERGER_LIETRAL> Exp_Aux()
	|	<ID> Exp_Aux()
	|	<THIS> Exp_Aux()
	|	<NEW> <INT> <LCOLCH> Exp() <RCOLCH> Exp_Aux()
	|	<NEW> <ID> <LPAREN> <RPAREN> Exp_Aux()
	|	<LPAREN> Exp() <RPAREN> Exp_Aux()
	|	<BANG> Exp() Exp_Aux()
}

void Exp_Aux(){}{
		<OP> Exp() (Exp_Aux())*
	|	<LCOLCH> Exp() <RCOLCH> Exp_Aux()
	|	<DOT> <LENGTH> Exp_Aux()
	|	<DOT> <ID> <LPAREN> (Exp_List())* <RPAREN> Exp_Aux()
	|	" "
}

void Explist(){}{
		Exp() (ExpRest())*
	|	" "
}

void ExpRest(){}{
	<COMMA> Exp()
}

